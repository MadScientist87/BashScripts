#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;      /* mutex lock for buffer */
pthread_cond_t c_reader = PTHREAD_COND_INITIALIZER; /* consumer waits on this cond var */
pthread_cond_t c_writer = PTHREAD_COND_INITIALIZER; /* producer waits on this cond var */

int varibleToBeRead = 0; /* varibleToBeRead */
int numOfWriters = 0;
int numOfReaders = 0;
pthread_t readerThreadList[5];
pthread_t WriterThreadList[5];
void *reader(void *param);
void *writer(void *param);
void callSleep();

int main(int argc, char *argv[])
{

    int i;

    for (i = 1; i <= 5; i++)
    {
        pthread_t thread;

        if (pthread_create(&thread, NULL, reader, NULL) != 0)
        {
            fprintf(stderr, "Unable to create reader thread\n");
            exit(1);
        }
        readerThreadList[i - 1] = thread;
    }

    /* create the threads; may be any number, in general */
    for (i = 1; i <= 5; i++)
    {
        pthread_t thread;
        if (pthread_create(&thread, NULL, writer, NULL) != 0)
        {
            fprintf(stderr, "Unable to create writer thread\n");
            exit(1);
        }
        WriterThreadList[i - 1] = thread;
    }

    /* wait for created thread to exit */
    for (i = 1; i <= 5; i++)
    {
        pthread_join(WriterThreadList[i - 1], NULL);
        pthread_join(readerThreadList[i - 1], NULL);
    }
    printf("Parent quiting\n");

    return 0;
}

void *reader(void *param)
{

    int i;
    int LocalReaders = 0; 
    for (i = 0; i < 5; i++)
    {
        callSleep();
        /* Insert into buffer */
        pthread_mutex_lock(&m);
        numOfReaders += 1;
        LocalReaders = numOfReaders;
        while (numOfWriters > 0)
        { /* block if buffer is full */
            pthread_cond_wait(&c_reader, &m);
        }

        /* if executing here, buffer not full so add element */
        printf("Reading Var: %d and the number of current readers %d\n", varibleToBeRead, LocalReaders);
        pthread_mutex_unlock(&m);
        numOfReaders--;
        pthread_cond_signal(&c_writer);

        fflush(stdout);

        printf("reader quiting\n");
        fflush(stdout);
    }
    return 0;
}

void *writer(void *param)
{

    int i;

    /* Insert into buffer */
    pthread_mutex_lock(&m);

    if (numOfReaders == 0)
    { /* block if buffer is full */
        pthread_cond_wait(&c_writer, &m);
    }
    callSleep();
    /* if executing here, buffer not full so add element */
    numOfWriters++;
    varibleToBeRead = i;
    printf("Writing Var: %d and the current number of writers %d \n", varibleToBeRead, numOfWriters);
    pthread_mutex_unlock(&m);
    numOfWriters--;
    pthread_cond_broadcast(&c_reader);
    pthread_cond_signal(&c_writer);

    fflush(stdout);

    printf("writer quiting\n");
    fflush(stdout);
    return 0;
}

void callSleep()
{
    int lower = 1, upper = 5;

    // Use current time as
    // seed for random generator
    srand(time(0));

    int num = (rand() %
               (upper - lower + 1)) +
              lower;
    sleep(num);
}